<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="renderer" content="webkit">
    <link type="text/css" rel="stylesheet" href="css/index.css"/>
    <title>css3_learn</title>
</head>
<body>
<div class="list">
    <h4>1.圆角：border-radius：</h4>

    <p>圆角属性为border-radius，有4个值，对应的方向为左上，右上，右下，左下</p>
    <h5>展示</h5>
    <span class="border-radius1"></span>
    <span class="border-radius2"></span>
</div>

<div class="list">
    <h4>2.阴影 box-shadow</h4>

    <p>box-shadow:增加阴影，支持一个或者多个</p>
    <img src="img/box-shadow.jpg">
    <b class="notice">注意：inset 可以写在参数的第一个或最后一个，其它位置是无效的。</b>
    <b class="notice">注意：X轴偏移和Y轴偏移可以设置负数</b>
    <h5>展示</h5>
    <ul class="ul_show clearfix">
        <li>
            <b>外阴影</b>

            <div class="box-shadow1"></div>
        <pre>
            .box_shadow{
                box-shadow:4px 2px 6px #333333;
            }
        </pre>
        </li>
        <li>
            <b>内阴影</b>

            <div class="box-shadow2"></div>
        <pre>
            .box_shadow{
                box-shadow:4px 2px 6px #333333 inset;
            }
        </pre>
        </li>
        <li>
            <b>多个阴影</b>
            如果添加多个阴影，只需用逗号隔开即可。
            <div class="box-shadow3"></div>
        <pre>
            .box_shadow{
                box-shadow:4px 2px 6px #f00, -4px -2px 6px #000, 0px 0px 12px 5px #33CC00 inset;
            }
        </pre>
        </li>
    </ul>
</div>

<div class="list">
    <h4>3.为边框应用图片 border-image</h4>

    <div class="lan">
        <em>语法为：</em>
        <img src="img/border-img.jpg">
    </div>
    <div class="lan">
        <div>使用下图做边框。可以为我们展示出三种不同的边框图片效果区别</div>
        <img src="img/border-img2.jpg">
    </div>
    <div class="clearfix">
        <div class="border-image border-image1">平铺 repeat</div>
        <div class="border-image border-image2">环绕 round</div>
        <div class="border-image border-image3">拉伸 stretch</div>
    </div>
</div>

<div class="list">
    <h4>4.渐变色彩</h4>

    <div class="lan">
        <em>语法为：</em>
        <img src="img/gradient_1.jpg" alt="渐变语法"/>
        <b class="notice">*径向渐变将to改为at</b>
    </div>
    <div class="lan">
        <div>参数为：</div>
        <img src="img/gradient_2.jpg" alt="渐变参数"/>
    </div>
    <div class="clearfix">
        <div class="gradient gradient1">
            线性渐变linear
        </div>
        <div class="gradient gradient2">
            径向渐变radial
        </div>
        <div class="gradient gradient3">
            多色彩径向渐变
        </div>
    </div>
</div>
<div class="list">
    <h4>5.text-overflow 与 word-wrap</h4>

    <div class="lan">
        <div>text-overflow用来设置是否使用一个省略标记（...）标示对象内文本的溢出。</div>
        <em>语法为：</em>
        <img src="img/text-overflow.jpg" alt="文本溢出"/>

        <div class="notice">
            但是text-overflow只是用来说明文字溢出时用什么方式显示，要实现溢出时产生省略号的效果，还须定义强制文本在一行内显示（white-space:nowrap）及溢出内容为隐藏（overflow:hidden），只有这样才能实现溢出文本显示省略号的效果，代码如下：
        </div>
        <pre>
            text-overflow:ellipsis;
            overflow:hidden;
            white-space:nowrap;
        </pre>
    </div>
    <div class="lan">
        <div>word-wrap也可以用来设置文本行为，当前行超过指定容器的边界时是否断开转行。</div>
        <em>语法：</em>
        <img src="img/word-warp.jpg" alt=""/>

        <div class="notice">
            normal为浏览器默认值，break-word设置在长单词或 URL地址内部进行换行，此属性不常用，用浏览器默认值即可。
        </div>
    </div>
</div>
<div class="list">
    <h4>6.嵌入字体@font-face</h4>

    <div class="lan">
        <div>@font-face能够加载服务器端的字体文件，让浏览器端可以显示用户电脑里没有安装的字体。</div>
        <em>语法：</em>
        <pre>
            @font-face{
                font-family:字体名称；
                src:字体文件在服务器上的路径。
            }
        </pre>
        <div>设置之后就可以像普通字体一样在（font-*）中设置字体样式了</div>
        <div>比如：</div>
        <pre>
            p{
                font-size:12px;
                font-family:"my font";
                /*必须项，设置@font-face中的font-family同样的值*/
            }
        </pre>
    </div>
    <div class="list">
        <h4>7.文本阴影</h4>

        <div class="lan">
            <em>语法：</em>
            <pre>
                text-shadow:X-offset Y-offset blur color;
            </pre>
        </div>
        <p>
            X-Offset：表示阴影的水平偏移距离，其值为正值时阴影向右偏移，反之向左偏移；<br/>

            Y-Offset：是指阴影的垂直偏移距离，如果其值是正值时，阴影向下偏移，反之向上偏移；<br/>

            Blur：是指阴影的模糊程度，其值不能是负值，如果值越大，阴影越模糊，反之阴影越清晰，如果不需要阴影模糊可以将Blur值设置为0；<br/>

            Color：是指阴影的颜色，其可以使用rgba色。<br/>

        </p>

        <div class="lan">
            <em>展示：</em>

            <p class="text-shadow">
                文本阴影text-shadow
            </p>
            <pre>
                text-shadow:1px 2px 1px red;
            </pre>
        </div>
    </div>
</div>
<div class="list">
    <h4>8.background-origin 设置元素背景图的其实位置</h4>

    <div class="lan">
        <p>设置背景元素图片的原始起始位置</p>
        <em>语法：</em>
        <pre>
            background-origin:border-box/padding-box/content-box
        </pre>
        <div class="notice">
            参数分别表示背景图片是从边框，还是内边距（默认值），或者是内容区域开始显示。
        </div>
    </div>
    <ul class="background-origin clearfix">
        <li class="background-origin1">border-box</li>
        <li class="background-origin2">padding-box</li>
        <li class="background-origin3">content-box</li>
    </ul>
</div>
<div class="list">
    <h4>9.background-clip 裁剪背景图片</h4>

    <div class="lan">
        <em>语法：</em>
        <pre>
            background-clip ： border-box | padding-box | content-box | no-clip
        </pre>
        <p>参数分别表示从边框、或内填充，或者内容区域向外裁剪背景。no-clip表示不裁切，和参数border-box显示同样的效果。backgroud-clip默认值为border-box。</p>
    </div>
    <ul class="clip clearfix">
        <li class="clip1">border-box</li>
        <li class="clip2">padding-box</li>
        <li class="clip3">content-box</li>
        <li class="clip4">no-clip</li>
    </ul>
</div>
<div class="list">
    <h4>10.background-size 背景图片大小</h4>

    <div class="lan">
        <em>语法：</em>
        <pre>
            background-size:auto | <长度值> |
            <百分比> | cover | contain;
        </pre>
        <p>
            说明：<br/>
            1、auto：默认值，不改变背景图片的原始高度和宽度；<br/>
            2、
            <长度值>：成对出现如200px 50px，将背景图片宽高依次设置为前面两个值，当设置一个值时，将其作为图片宽度值来<b>等比缩放</b>；<br/>
                3、
                <百分比>：0％~100％之间的任何值，将背景图片宽高依次设置为所在元素宽高乘以前面百分比得出的数值，当设置一个值时同上；<br/>
                    4、cover：顾名思义为覆盖，即将背景图片等比缩放以<b>填满整个容器</b>；<br/>
                    5、contain：容纳，即将背景图片等比缩放至某一边<b>紧贴容器边缘为止</b>。
        </p>
    </div>
    <ul class="bg-size clearfix">
        <li class="bg-size1">auto</li>
        <li class="bg-size2">px</li>
        <li class="bg-size3">百分比</li>
        <li class="bg-size4">cover</li>
        <li class="bg-size5">contain</li>
    </ul>
</div>
<div class="list">
    <h4>11.多重背景</h4>

    <p>
        多重背景，也就是CSS2里background的属性外加origin、clip和size组成的新background的多次叠加，缩写时为用逗号隔开的每组值；用分解写法时，如果有多个背景图片，而其他属性只有一个（例如background-repeat只有一个），表明所有背景图片应用该属性值。</p>

    <div class="lan">
        <p>语法缩写如下</p>
        <pre>
            background ： [background-color] | [background-image] | [background-position][<b class="red">/</b>background-size] | [background-repeat] | [background-attachment] | [background-clip] | [background-origin],...
        </pre>
        <p>
            可以把上面的缩写拆解成以下形式：<br/>
            background-image:url1,url2,...,urlN;
        </p>
        <pre>
            background-repeat : repeat1,repeat2,...,repeatN;
            backround-position : position1,position2,...,positionN;
            background-size : size1,size2,...,sizeN;
            background-attachment : attachment1,attachment2,...,attachmentN;
            background-clip : clip1,clip2,...,clipN;
            background-origin : origin1,origin2,...,originN;
            background-color : color;
        </pre>
        <b>注意：</b>

        <p>
            1.用逗号隔开每组 background 的缩写值；<br/>
            2.如果有 size 值，需要紧跟 position 并且用 "/" 隔开；<br/>
            3.如果有多个背景图片，而其他属性只有一个（例如 background-repeat 只有一个），表明所有背景图片应用该属性值。<br/>
            4.<b class="red"> background-color </b> 只能设置一个。
        </p>

        <div class="bg-demo"></div>
        <pre>
            background-image: url("../img/bg1.jpg"),
                              url("../img/bg2.jpg"),
                              url("../img/bg3.jpg");
            background-position: left top ,100px 0,200px 0;
            background-repeat: no-repeat,no-repeat,no-repeat;
        </pre>
        <div class="bg-demo2"></div>
        <p>也可以这么写</p>
        <pre>
            background: url("../img/bg1.jpg") no-repeat left top,
                        url("../img/bg2.jpg") no-repeat 100px 0,
                        url("../img/bg3.jpg") no-repeat 200px 0;
        </pre>
    </div>
</div>
<h4>练习：css3导航条</h4>

<div class="ex">
    <ul class="nav">
        <li><a href="">Home</a></li>
        <li><a href="">About Me</a></li>
        <li><a href="">Portfolio</a></li>
        <li><a href="">Blog</a></li>
        <li><a href="">Resources</a></li>
        <li><a href="">Contact Me</a></li>
    </ul>
</div>
<div class="list">
    <h4>12.CSS3选择器</h4>

    <p> 在HTML中，通过各种各样的属性可以给元素增加很多附加的信息。例如，通过id属性可以将不同div元素进行区分。<br/>
        在CSS2中引入了一些属性选择器，而CSS3在CSS2的基础上对属性选择器进行了扩展，新增了3个属性选择器，使得属性选择器有了通配符的概念，这三个属性选择器与CSS2的属性选择器共同构成了CSS功能强大的属性选择器。如下表所示：
    </p>
    <img src="img/css3chose.jpg" alt=""/>

    <div class="lan">
        <p>实例展示：</p>

        <p>HTML代码</p>
        <textarea>
            <a href="xxx.pdf">我链接的是PDF文件</a>
            <a href="#" class="icon">我类名是icon</a>
            <a href="#" title="我的title是more">我的title是more</a>
        </textarea>

        <p>css代码</p>
        <pre>
            a[<b class="red">class^</b>=icon]{
              background: green;
              color:#fff;
            }
            a[<b class="red">href$</b>=pdf]{
              background: orange;
              color: #fff;
            }
            a[<b class="red"> title*</b>=more]{
              background: blue;
              color: #fff;
            }
        </pre>
    </div>
    <p>效果展示</p>

    <div class="chose">
        <a href="xxx.pdf">我链接的是PDF文件</a>
        <a href="#" class="icon">我类名是icon</a>
        <a href="#" title="我的title是more">我的title是more</a>
    </div>
</div>
<div class="list">
    <h4>13.伪类结构选择器：root</h4>

    <p>
        <b class="red">:root</b>选择器
        从字面上我们就可以很清楚的理解是根选择器，他的意思就是匹配元素E所在文档的根元素。在HTML文档中，根元素始终是html标签。<br/>
        例如：：root{background:blue}<br/>
        与html{background:blue}的效果是相同的。
    </p>
</div>
<div class="list">
    <h4>14.结构性伪类选择器：not</h4>

    <p>
        <b class="red">:not</b>选择器称为否定选择器，和jQuery中的:not选择器一模一样，可以选择除某个元素之外的所有元素。就拿form元素来说，比如说你想给表单中除submit按钮之外的input元素添加红色边框，CSS代码可以写成：
    </p>

    <div class="lan">
        <pre>
            div{
              padding: 10px 20px;
              min-height: 50px;
            }
            div:not([id="footer"]){
              background: orange;
            }
        </pre>
        <h5>相关html代码</h5>
        <textarea>
            <form action="#">
                <div id="header">页头</div>
                <div id="page">页体</div>
                <div id="footer">页脚</div>
        </textarea>
    </div>
    <div class="chose_not">
        <div class="header">页头</div>
        <div class="page">页体</div>
        <div class="footer">页脚</div>
    </div>
</div>
<div class="list">
    <h4>14.结构性伪类选择器：empty</h4>

    <p>
        <b class="red">:empty</b>选择器表示的就是空。用来选择没有任何内容的元素，这里没有内容指的是一点内容都没有，<b>哪怕是一个空格</b>。
    </p>
    <h5>相关代码：</h5>
    html：
    <div class="lan">
        <textarea name="" id="" cols="30" rows="10" readonly>
            <p>我是一个段落</p>
            <p> <!-- 我这里有一个空格 --></p>
            <p></p>​<!--我这里没有任何内容-->
        </textarea>
        css代码：
        <pre>
            p{
             min-height: 30px;
            }
            p:empty {
               border: 1px solid green;
            }​
        </pre>
    </div>
    <h5>效果展示：</h5>
    <div class="empty_show">
        <p>我是一个段落</p>
        <p>  </p>
        <p></p>​
    </div>
</div>
<div class="list">
    <h4>15.结构性伪类选择器：target</h4>
    <p>
        <b class="red">:target</b>选择器为目标选择器，用来匹配文档（页面）的 <b>url的某个标识符的目标元素</b>
    </p>
    <div class="lan">
        相关代码：<br/>
        html代码：<br/>
        <textarea name="" id="" cols="30" rows="10" readonly>
            <h2><a href="#brand">Brand</a></h2>
            <div class="menuSection" id="brand">
                content for Brand
            </div>
        </textarea>
        css代码：<br/>
        <pre>
            .menuSection{
              background:#eee;
            }
            :target{/*这里的:target就是指id="brand"的div对象*/
              background:#333;
              color:#fff;
            }
        </pre>
    </div>
    效果显示：
    <div class="target_show">
        <a href="#tag">点击按钮改变颜色</a>
        <p id="tag">内容内容</p>
    </div>
</div>
<div class="last">
    <h4>16.结构性选择伪类：first:child</h4>
    <p>
        <b class="red">:first-child</b>选择器表示的是  <b>选择父元素的第一个子元素的元素</b>。简单点理解就是选择元素中的第一个子元素，记住是 <b>子元素</b>，而不是后代元素。
    </p>
</div>
<div class="lsat">
    <h4>17.结构性伪类选择器：last-child</h4>
    <p>
        <b class="red">:first-child</b>选择器表示的是  <b>选择父元素的最后一个子元素的元素</b>。简单点理解就是选择元素中的最后一个子元素，记住是 <b>子元素</b>，而不是后代元素。
    </p>
</div>
<div class="last">
    <h4>18.结构性伪类选择器：nth-child(n)</h4>
    <p>
        <b class="red">：nth-child(n)</b>”选择器用来定位 <b>某个父元素的一个或多个特定的子元素</b>。其中“n”是其参数，而且可以是整数值(1,2,3,4)，也可以是表达式(2n+1、-n+5)和关键词(odd、even)，但参数n的起始值始终是1，而不是0。也就是说，参数n的值为0时，选择器将选择不到任何匹配的元素。
    </p>
    <div class="lan">
        html代码：
        <textarea name="" id="" cols="30" rows="10" readonly>
            <ul>
                <li>item1</li>
                <li>item2</li>
                <li>item3</li>
                <li>item4</li>
                <li>item5</li>
                <li>item6</li>
                <li>item7</li>
                <li>item8</li>
                <li>item9</li>
                <li>item10</li>
            </ul>​
        </textarea>
        CSS代码：
        <pre>
            ul li:nth-child(2n){
               background: #333333;
               color: #ffffff;
            }
        </pre>
    </div>
    <ul class="child_show">
        <li>item1</li>
        <li>item2</li>
        <li>item3</li>
        <li>item4</li>
        <li>item5</li>
        <li>item6</li>
        <li>item7</li>
        <li>item8</li>
        <li>item9</li>
        <li>item10</li>
    </ul>
</div>
<div class="list">
    <h4>19.结构性伪类选择器：nth-last-child(n)</h4>
    <p>
        <b class="red">:nth-last-child(n)</b>选择器和前面的“:nth-child(n)”选择器非常的相似，只是这里多了一个“last”，所起的作用和“:nth-child(n)”选择器有所区别，从某父元素的最后一个子元素开始计算，来选择特定的元素。
    </p>
</div>
<div class="last">
    <h4>20.first-of-type选择器</h4>
    <p>
        <b class="red">.first-of-type</b>选择器类似于“:first-child”选择器，不同之处就是 <b>指定了元素的类型</b>,其主要用来定位一个父元素下的某个类型的第一个子元素。
    </p>
    <p>
        示例演示：<br/>
        通过“:first-of-type”选择器，定位div容器中的第一个p元素（p不一定是容器中的第一个子元素），并设置其背景色为橙色。
    </p>
    <div class="lan">
        HTML:
        <textarea name="" id="" cols="30" rows="10" readonly>
            <div class="wrapper">
                <div>我是一个块元素，我是.wrapper的第一个子元素</div>
                <p>我是一个段落元素，我是不是.wrapper的第一个子元素，但是他的第一个段落元素</p>
                <p>我是一个段落元素</p>
                <div>我是一个块元素</div>
            </div>
        </textarea>
        CSS:
        <pre>
            .wrapper {
              width: 500px;
              margin: 20px auto;
              padding: 10px;
              border: 1px solid #ccc;
              color: #fff;
            }
            .wrapper > div {
              background: green;
            }
            .wrapper > p {
              background: blue;
            }
            /*我要改变第一个段落的背景为橙色*/
            .wrapper > p:first-of-type {
              background: orange;
            }
        </pre>
    </div>
    效果展示：
    <div class="type_show_1">
        <div>我是一个块元素，我是.wrapper的第一个子元素</div>
        <p>我是一个段落元素，我是不是.wrapper的第一个子元素，但是他的第一个段落元素</p>
        <p>我是一个段落元素</p>
        <div>我是一个块元素</div>
    </div>
</div>
<div class="list">
    <h4>21.nth-of-type(n)选择器</h4>
    <p>
        <b class="red">:nth-of-type(n)</b>选择器和“:nth-child(n)”选择器非常类似，不同的是它只计算父元素中指定的某种类型的子元素。当某个元素中的子元素不单单是同一种类型的子元素时，使用“:nth-of-type(n)”选择器来定位于父元素中某种类型的子元素是非常方便和有用的。在“:nth-of-type(n)”选择器中的“n”和“:nth-child(n)”选择器中的“n”参数也一样，可以是 <b>具体的整数</b>，也可以是 <b>表达式</b>，还可以是 <b>关键词</b>。
    </p>
    <div class="lan">
        实例：<br/>
        通过“:nth-of-type(2n)”选择器，将容器“div.wrapper”中偶数段数的背景设置为橙色。<br/>
        HTML:
        <textarea name="" id="" cols="30" rows="10" readonly>
            <div class="wrapper">
                <div>我是一个Div元素</div>
                <p>我是一个段落元素</p>
                <div>我是一个Div元素</div>
                <p>我是一个段落</p>
                <div>我是一个Div元素</div>
                <p>我是一个段落</p>
                <div>我是一个Div元素</div>
                <p>我是一个段落</p>
                <div>我是一个Div元素</div>
                <p>我是一个段落</p>
                <div>我是一个Div元素</div>
                <p>我是一个段落</p>
                <div>我是一个Div元素</div>
                <p>我是一个段落</p>
                <div>我是一个Div元素</div>
                <p>我是一个段落</p>
            </div>
        </textarea>
        CSS:
        <pre>
            .wrapper > p:nth-of-type(2n){
              background: orange;
            }
        </pre>
        演示效果：
        <div class="type_show_2">
            <div>我是一个Div元素</div>
            <p>我是一个段落元素</p>
            <div>我是一个Div元素</div>
            <p>我是一个段落</p>
            <div>我是一个Div元素</div>
            <p>我是一个段落</p>
            <div>我是一个Div元素</div>
            <p>我是一个段落</p>
            <div>我是一个Div元素</div>
            <p>我是一个段落</p>
            <div>我是一个Div元素</div>
            <p>我是一个段落</p>
            <div>我是一个Div元素</div>
            <p>我是一个段落</p>
            <div>我是一个Div元素</div>
            <p>我是一个段落</p>
        </div>
    </div>
</div>
<div class="last">
    <h4>22.last-of-type选择器</h4>
    <p>
        <b class="red">:last-of-tyle</b>选择器和“:first-of-type”选择器功能是一样的，不同的是他选择是父元素下的某个类型的 <b>最后一个子元素</b>。
    </p>
</div>
<div class="last">
    <h4>23.nth-last-of-type(n)选择器</h4>
    <p>
        <b class="red">:nth-last-of-type(n)</b>选择器和“:nth-of-type(n)”选择器是一样的，选择父元素中指定的某种子元素类型，但它的 <b>起始方向是从最后一个子元素开始</b>，而且它的使用方法类似于上节中介绍的“:nth-last-child(n)”选择器一样。
    </p>
</div>
<div class="list">
    <h4>24.only-child</h4>
    <p>
        <b class="red">:only-child</b>选择器选择的是父元素中只有一个子元素，而且只有唯一的一个子元素。也就是说，匹配的元素的父元素中仅有一个子元素，而且是一个 <b>唯一的子元素</b>。
    </p>
    <div class="lan">
        演示案例：<br/>
        HTML: <br/>
        <textarea name="" id="" cols="30" rows="10" readonly>
            <div class="post">
                <p>我是一个段落</p>
                <p>我是一个段落</p>
                <p>我是一个段落</p>
            </div>
            <div class="post">
                <p>我是这个容器仅有的一个段落</p>
            </div>
        </textarea>
        CSS：<br/>
        <pre>
            .post p {
              background: green;
              color: #fff;
              padding: 10px;
            }
            .post p:only-child {
              background: orange;
            }
        </pre>
        效果展示:
        <div class="post">
            <p>我是一个段落</p>
            <p>我是一个段落</p>
            <p>我是一个段落</p>
        </div>
        <div class="post">
            <p>我是这个容器仅有的一个段落</p>
        </div>
    </div>
</div>
<div class="list">
    <h4>25.only-of-type选择器</h4>
    <p>
        <b class="red">:only-of-type</b>选择器用来选择一个元素是它的父元素的 <b>唯一一个相同类型的子元素</b>。这样说或许不太好理解，换一种说法。“:only-of-type”是表示一个元素他有很多个子元素，而其中只有一种类型的子元素是唯一的，使用“:only-of-type”选择器就可以选中这个元素中的唯一一个类型子元素。
    </p>
    <div class="lan">
        示例演示: <br/>
        HTML： <br/>
        <textarea name="" id="" cols="30" rows="10" readonly>
            <div class="wrapper">
                <p>我是一个段落</p>
                <p>我是一个段落</p>
                <p>我是一个段落</p>
                <div>我是一个Div元素</div>
            </div>
            <div class="wrapper">
                <div>我是一个Div</div>
                <ul>
                    <li>我是一个列表项</li>
                </ul>
                <p>我是一个段落</p>
            </div>
        </textarea>
        CSS: <br/>
        <pre>
            .wrapper > div:only-of-type {
                  background: orange;
                }
        </pre>
        效果展示: <br/>
        <div class="only_show">
            <p>我是一个段落</p>
            <p>我是一个段落</p>
            <p>我是一个段落</p>
            <div>我是一个Div元素</div>
        </div>
        <div class="only_show">
            <div>我是一个Div</div>
            <ul>
                <li>我是一个列表项</li>
            </ul>
            <p>我是一个段落</p>
        </div>
    </div>
</div>
<div class="list">
    <h4>26.:enabled选择器和:disabled选择器</h4>
    <p>
        在Web的表单中，有些表单元素有可用 <b class="red">:enabled</b> 和不可用 <b class="red">:disabled</b> 状态，比如输入框，密码框，复选框等。在默认情况之下，这些表单元素都处在 <b>可用状态</b> 。那么我们可以通过伪选择器“:enabled”对这些表单元素设置样式。如果这些表单处于 <b>不可用状态</b> ，那么可以通过:disabled对这些表单元素设置样式。要正常使用“:disabled”选择器，需要在表单元素的HTML中设置“disabled”属性。
    </p>
    <div class="lan">
        实例演示： <br/>
        设置两个输入框的样式. <br/>
        HTML:
        <textarea name="" id="" cols="30" rows="10" readonly>
            <form action="#">
                <div>
                    <label for="name">Text Input:</label>
                    <input type="text" name="name" id="name" placeholder="可用输入框"  />
                </div>
                <div>
                    <label for="name">Text Input:</label>
                    <input type="text" name="name" id="name" placeholder="禁用输入框"  disabled="disabled" />
                </div>
            </form>
        </textarea>
        CSS: <br/>
        <pre>
            div{
              margin: 20px;
            }
            input[type="text"]:enabled {
              background: #ccc;
              border: 2px solid red;
            }
        </pre>
        效果展示:
        <form action="#" class="able_show">
            <div>
                <label for="name">Text Input:</label>
                <input type="text" name="name" id="name" placeholder="可用输入框"  />
            </div>
            <div>
                <label for="name">Text Input:</label>
                <input type="text" name="name" id="name" placeholder="禁用输入框"  disabled="disabled" />
            </div>
        </form>
    </div>
</div>
<div class="list">
    <h4>27. :checked选择器</h4>
    <p>在表单元素中，单选按钮和复选按钮都具有 <b>选中和未选中状态</b>。（大家都知道，要覆写这两个按钮默认样式比较困难）。在CSS3中，我们可以通过状态选择器“:checked”配合其他标签实现自定义样式。而 <b class="red">:checked</b>表示的是选中状态。</p>
    <div class="lan">
        实例演示：<br/>
        通过：checked状态来自定义选框效果。 <br/>
        HTML：<br/>
        <textarea name="" id="" cols="30" rows="10" readonly>
            <form action="#">
                <div class="check_show">
                    <div class="box">
                        <input type="checkbox" checked="checked" id="usename" /><span>√</span>
                    </div>
                    <lable for="usename">我是选中状态</lable>
                </div>

                <div class="check_show">
                    <div class="box">
                        <input type="checkbox"  id="usepwd" /><span>√</span>
                    </div>
                    <label for="usepwd">我是未选中状态</label>
                </div>
            </form>
        </textarea>
        CSS:
        <pre>
            form {
              border: 1px solid #ccc;
              padding: 20px;
              width: 300px;
              margin: 30px auto;
            }

            .wrapper {
              margin-bottom: 10px;
            }

            .box {
              display: inline-block;
              width: 20px;
              height: 20px;
              margin-right: 10px;
              position: relative;
              border: 2px solid orange;
              vertical-align: middle;
            }

            .box input {
              opacity: 0;
              position: absolute;
              top:0;
              left:0;
            }

            .box span {
              position: absolute;
              top: -10px;
              right: 3px;
              font-size: 30px;
              font-weight: bold;
              font-family: Arial;
              -webkit-transform: rotate(30deg);
              transform: rotate(30deg);
              color: orange;
            }

            input[type="checkbox"] + span {
              opacity: 0;
            }

            input[type="checkbox"]:checked + span {
              opacity: 1;
            }
        </pre>
        效果展示：
        <form action="#" class="check_s">
            <div class="check_show">
                <div class="box">
                    <input type="checkbox" checked="checked" id="usename" /><span></span>
                </div>
                <lable for="usename">我是选中状态</lable>
            </div>

            <div class="check_show">
                <div class="box">
                    <input type="checkbox"  id="usepwd" /><span></span>
                </div>
                <label for="usepwd">我是未选中状态</label>
            </div>
        </form>
    </div>
</div>
<div class="list">
    <h4>28.::selection选择器</h4>
    <p>
        <b class="red">::selection</b> 伪元素是用来匹配 <b>突出显示的文本(用鼠标选择文本时的文本)</b>。浏览器默认情况下，用鼠标选择网页文本是以“深蓝的背景，白色的字体”显示的，效果如下图所示：
        <img src="img/selection.jpg" alt="selection"/> <br/>
        从上图中可以看出，用鼠标选中“专注IT、互联网技术”、“纯干货、学以致用”、“没错、这是免费的”这三行文本中，默认显示样式为：蓝色背景、白色文本。<br/>
        有的时候设计要求,不使用上图那种浏览器默认的突出文本效果，需要一个与众不同的效果，此时“::selection”伪元素就非常的实用。<b>不过在Firefox浏览器还需要添加前缀。</b>
    </p>
    <div class="lan">
        效果展示: <br/>
        通过“::selection”选择器，将Web中选中的文本背景变成橙色，文本变成红色。<br/>
        html:
        <textarea name="" id="" cols="30" rows="10" readonly>
            <p>“::selection”伪元素是用来匹配突出显示的文本。浏览器默认情况下，选择网站文本是深蓝的背景，白色的字体，</p>
        </textarea>
        CSS:
        <pre>
            ::-moz-selection {
              background: orange;
              color: red;
            }
            ::selection {
              background: orange;
              color: red;
            }
        </pre>
        效果展示：
        <p class="selection">
            选中我试试看？
        </p>
    </div>
</div>
<div class="list">
    <h4>29.:read-only选择器和:read-write选择器</h4>
    <p>
        <b class="red">:read-only</b>伪类选择器用来指定处于只读状态元素的样式。简单点理解就是，元素中设置了"<b>readonly='readonly'</b>"
    </p>
    <div class="lan">
        实例演示：<br/>
        通过“:read-only”选择器来设置地址文本框的样式，通过read-write设置姓名文本框的样式<br/>
        HTML: <br/>
        <textarea name="" id="" cols="30" rows="10" readonly>
            <form action="#">
                <div>
                    <label for="name">姓名:</label>
                    <input type="text" name="name" id="name" placeholder="大漠" />
                </div>
                <div>
                    <label for="name">年龄:</label>
                    <input type="text" name="age" id="age" placeholder="输入您的年龄" />
                </div>
                <div>
                    <label for="address">地址:</label>
                    <input type="text" name="address" id="address" placeholder="中国上海" readonly="readonly" />
                </div>
            </form>
        </textarea>
        CSS: <br/>
        <pre>
            form {
              width: 300px;
              padding: 10px;
              border: 1px solid #ccc;
              margin: 50px auto;
            }
            form > div {
              margin-bottom: 10px;
            }

            input[type="text"]{
              border: 1px solid orange;
              padding: 5px;
              background: #fff;
              border-radius: 5px;
            }

            input[type="text"]:-moz-read-only{
              border-color: #ccc;
            }
            input[type="text"]:read-only{
              border-color: #ccc;
            }
        </pre>
        结果演示: <br/>
        <form action="#" class="readonly">
            <div>
                <label for="name">姓名:</label>
                <input type="text" name="name" id="name" placeholder="china" />
            </div>
            <div>
                <label for="name">年龄:</label>
                <input type="text" name="age" id="age" placeholder="输入您的年龄" />
            </div>
            <div>
                <label for="address">地址:</label>
                <input type="text" name="address" id="address" placeholder="中国上海" readonly="readonly" />
            </div>
        </form>
    </div>
</div>
<div class="list">
    <h4>30. ::before和::after</h4>
    <p>
        <b class="red">::before和::after</b>这两个主要用来给前面或者后面插入内容。这两个常和"content"配合使用，使用的场景最多的就是 <b>清除浮动</b>。
    </p>
    <div class="lan">
        清除浮动代码实例：
        <pre>
            .clearfix::before,
            .clearfix::after {
                content: ".";
                display: block;
                height: 0;
                visibility: hidden;
            }
            .clearfix:after {clear: both;}
            .clearfix {zoom: 1;}
        </pre>
    </div>
</div>
<div class="liat">
    <h4>31.变形--旋转 rotate()</h4>
    <p>
        <b class="red">旋转rotate()函数</b>通过指定的角度参数使元素相对原点进行旋转。它主要在二维空间内进行操作，设置一个角度值，用来指定旋转的幅度。如果这个值为正值，元素相对原点中心顺时针旋转；如果这个值为负值，元素相对原点中心逆时针旋转。如下图所示：
    </p>
    <img src="img/rotate.jpg" alt=""/>
    <div class="lan">
        效果展示: <br/>
        html: <br/>
        <textarea name="" id="" cols="30" rows="10" readonly>
            <div class="rotate_show">
                <p></p>
            </div>
        </textarea>
        CSS:
        <pre>
            .rotate_show{
                width:100px;
                height:100px;
                border:1px solid orange;
                margin:20px;
            }
            .rotate_show p{
                 width:100px;
                 height:100px;
                 background:orange;
                transform:rotate(45deg);
                -webkit-transform:rotate(45deg);
            }
        </pre>
        效果展示:
        <div class="rotate_show">
            <p></p>
        </div>
    </div>
</div>
<div class="list">
    <h4>32.变形-扭曲 skew()</h4>
    <p>
        <b class="red">skew()</b>函数能够让元素 <b>倾斜显示</b>。他可以将一个对象以期中心位置围绕这X轴和Y轴按照一定的角度倾斜。这与rotate()函数旋转不停，rotate()函数只是旋转，不会改变元素的形状。skew()函数不会旋转，而是只会改变元素的形状。
    </p>
    <div class="lan">
        通过skew()函数将长方形变成平行四边形 <br/>
        HTML: <br/>
        <textarea name="" id="" cols="30" rows="10" readonly>
            <div class="skew">
                <div>我变成平行四边形</div>
            </div>
        </textarea>
        CSS: <br/>
        <pre>
            .skew{
                width:200px;
                height:200px;
                backgroun:orange;
                transform:skew(45deg);
                -webkit-transform:skew(45deg);
                -moz-transform:skew(45deg);
            }
        </pre>
        效果展示： <br/>
        <div class="skew">
            <div>我是平行四边形</div>
        </div>
    </div>
</div>
<div class="list">
    <h4>33.变形--缩放scale()</h4>
    <p>
        <b class="red">缩放 scale()函数</b> 让元素根据中心原点对对象进行缩放。 <br/>
        缩放 scale 具有三种情况 <br/>
        <b>1.scale（X,Y）使元素水平和垂直方向同时缩放</b>（也就是X轴和Y轴同时缩放。）<br/>
        <img src="img/scale1.jpg" alt=""/> <br/>
        例如 <br/>
    </p>
    <div class="lan">
        <pre>
            div:hover{
                -webkit-transform:scale(1.5,0.5);
                -moz-transform:scale(1.5,0.5);
                transform:scale(1.5,0.5);
            }
         </pre>
    </div>
    <p>
        注意:Y是一个可选参数，如果没有设置Y值，则表示X,Y两个方向缩放倍数是一样的。
    </p>
    <p>
        <b>2.scaleX(x)元素仅水平方向缩放</b>（X轴缩放）<br/>
        <img src="img/scale2.jpg" alt=""/> <br/>
        <b>3.scaleY(y)元素仅垂直方向缩放</b>（Y轴缩放）<br/>
    </p>
    效果展示：
    <div class="lan">
        <ul class="scale clearfix">
            <li><a href="">X,Y 我将整体放大1.5倍</a></li>
            <li><a href="">X 我将X轴放大1.5倍</a></li>
            <li><a href="">Y 我将Y轴放大1.5倍</a></li>
        </ul>
    </div>
    <div class="notice">
        注意： scale()的取值默认的值为1，当值设置为0.01到0.99之间的任何值，作用使一个元素缩小；而任何大于或等于1.01的值，作用是让元素放大。
    </div>
</div>
<div class="list">
    <h4>34.变形-位移</h4>
    <p>
        <b class="red">translate()函数</b>可以将元素向指定的方向移动，类似于position中的relative。或以简单的理解为，使用translate()函数，可以把元素从原来的位置移动，而不影响在X、Y轴上的任何Web组件。
        <br/>
        translate我们分为三种情况。 <br/>
        <b>1.translate(x,y)水平和垂直方向同时移动。</b>（也就是X轴和Y轴同时移动。） <br/>
        <img src="img/translate1.jpg" alt=""/> <br/>
        <b>2.translate(x)仅水平方向移动。</b>（X轴移动） <br/>
        <img src="img/translate2.jpg" alt=""/> <br/>
        <b>3.translate(Y) 仅垂直方向移动。</b>（Y轴移动） <br/>
        <img src="img/translate3.jpg" alt=""/><br/>
    </p>
    <div class="lan">
        事例：将一个不知道宽高的元素实现水平垂直居中。<br/>
        HTML: <br/>
        <textarea name="" id="" cols="30" rows="10" readonly>
            <div class="translate">
                <div class="translate_warp">
                    我不知道我的宽度和高是多少，我要实现水平垂直居中
                </div>
            </div>
        </textarea>
        CSS： <br/>
        <pre>
            .translate{
                position:relative;
            }
            .translate_warp{
                position:absolute;
                top:50%;
                left:50%;
                transfrom:translate(-50%,-50%);
            }
        </pre>
        效果展示：
        <div class="translate">
            <div class="translate_warp">
                我不知道我的宽度和高是多少，我要实现水平垂直居中
            </div>
        </div>
    </div>
</div>
<div class="list">
    <h4>35.变形-矩阵matrix()</h4>
    <p>
        <b class="red">matrix()</b> 是一个含六个值的(a,b,c,d,e,f)变换矩阵，用来指定一个2D变换，相当于直接应用一个[a b c d e f]变换矩阵。就是基于水平方向（X轴）和垂直方向（Y轴）重新定位元素,此属性值使用涉及到数学中的矩阵，我在这里只是简单的说一下CSS3中的transform有这么一个属性值，如果需要深入了解，需要对数学矩阵有一定的知识。
    </p>
    <div class="notice">
       * matrix() 是一个含六个值的(a,b,c,d,e,f)变换矩阵，用来指定一个2D变换，相当于直接应用一个[a b c d e f]变换矩阵。就是基于水平方向（X轴）和垂直方向（Y轴）重新定位元素。<br/>
        matrix(scaleX(),skewX(),skewY(),scaleY(),translateX(),translateY());
    </div>
    <div class="lan">
        实例演示：通过matrix()函数来模拟transfrom：translate（）的位移效果。 <br/>
        HTML: <br/>
        <textarea name="" id="" cols="30" rows="10" readonly>
            <div class="matrix">
                <div></div>
            </div>
        </textarea>
        CSS: <br/>
        <pre>
            .matrix {
              width: 300px;
              height: 200px;
              border: 2px dotted red;
              margin: 40px auto;
            }
            .matrix div {
              width:300px;
              height: 200px;
              background: orange;
              -webkit-transform: matrix(1,0,0,1,50,50);
              -moz-transform:matrix(1,0,0,1,50,50);
              transform: matrix(1,0,0,1,50,50);
            }
        </pre>
        效果展示:
        <div class="matrix">
            <div></div>
        </div>
    </div>
</div>
<div class="list">
    <h4>36.原点变形-transform-orgin</h4>
    <p>
        任何一个元素都有一个中心点，默认情况下，其中心点是居于元素X轴和Y轴50%处，如下图所示：<br/>
        <img src="img/transform-orgin1.jpg" alt=""/> <br/>
        在没有重置transform-orgin改变元素原点位置的情况下，CSS变形进行的旋转、位移、缩放，扭曲等操作都是以元素自己中心位置进行变形。但很多时候，我们可以通过transform-origin来对元素进行原点位置改变，使元素原点不在元素的中心位置，以达到需要的原点位置。
        <br/>
        transform-origin取值和元素设置背景中的background-position取值类似，如下表所示： <br/>
        <img src="img/transform-orgin2.jpg" alt=""/>
    </p>
    <div class="lan">
        实例展示：<br/>
        通过transform-origin改变元素原点到左上角，然后进行顺时旋转45度。<br/>
        HTML：<br/>
        <textarea name="" id="" cols="30" rows="10" readonly>
            <div class="wrapper">
                <div>原点在默认位置处</div>
            </div>
            <div class="wrapper transform-origin">
                <div>原点重置到左上角</div>
            </div>
        </textarea>
        CSS:
        <pre>
            .wrapper {
              width: 300px;
              height: 300px;
              float: left;
              margin: 100px;
              border: 2px dotted red;
              line-height: 300px;
              text-align: center;
            }
            .wrapper div {
              background: orange;
              -webkit-transform: rotate(45deg);
              transform: rotate(45deg);
            }
            .transform-origin div {
              -webkit-transform-origin: left top;
              transform-origin: left top;
            }
        </pre>
        效果展示:
        <div class="clearfix">
            <div class="origin">
                <div>原点在默认位置处</div>
            </div>
            <div class="origin transform-origin">
                <div>原点重置到左上角</div>
            </div>
        </div>
    </div>
</div>
<div class="list">
    <h4>37.动画-过渡属性 transition-property</h4>
    <p>
        早期在Web中要实现动画效果，都是依赖于JavaScript或Flash来完成。但在CSS3中新增加了一个新的模块transition，它可以通过一些简单的CSS事件来触发元素的外观变化，让效果显得更加细腻。
        <b>
        简单点说，就是通过鼠标的单击、获得焦点，被点击或对元素任何改变中触发，并平滑地以动画效果改变CSS的属性值。
        </b>
    </p>
    <div class="lan">
        <pre>
            在CSS中创建简单的过渡效果可以从以下几个步骤来实现：<br/>
            第一，在默认样式中声明元素的初始状态样式；<br/>
            第二，声明过渡元素最终状态样式，比如悬浮状态；<br/>
            第三，在默认样式中通过添加过渡函数，添加一些不同的样式。<br/>
        </pre>
        CSS3的过渡transition属性是一个符合属性，主要包括以下几个子元素：<br/>
        1.transition-property:指定过渡属性或动态模拟CSS属性。<br/>
        2.transition-duration:指定完成过渡所需的时间 <br/>
        3.transition-timing-function:指定过渡函数 <br/>
        4.transition-delay:指定开始出现的延迟时间 <br/>
    </div>
    <p>
        <b class="red">transition-property</b>用来指定过渡动画的CSS属性名称，而这个过渡属性只有具备一个中点值的属性（需要产生动画的属性）才能具备过渡效果，其对应具有过渡的CSS属性主要有：
        <br/>
        <img src="img/transition-property.jpg" alt=""/>
    </p>
    <div class="lan">
        效果展示：<br/>
        HTML：<br/>
        <textarea name="" id="" cols="30" rows="10" readonly>
            <div class="property"></div>
        </textarea>
        CSS: <br/>
        <pre>
            div {
              width: 200px;
              height: 200px;
              background-color:red;
              margin: 20px auto;
            -webkit-transition-property:background-color,width;
              transition-property: background-color,width;
              -webkit-transition-duration:.5s;
              transition-duration:.5s;
              -webkit-transition-timing-function: ease;
              transition-timing-function: ease;
              -webkit-transition-delay: .1s;
              transition-delay:.1s;
              /*也可以缩写为*/
              -webkit-transition:width,background-color,width .5s ease .1s;
              transition:width,background-color,width .5s ease .1s;
            }
            div:hover {
              background-color: orange;
              width:300px;
            }
        </pre>
        效果展示:
        <div class="property"></div>
    </div>
    <p>
        <b>特别注意：</b>当“transition-property”属性设置为 <b class="red">all</b>时，表示的是所有中点值的属性 <br/>
        用一个简单的例子来说明这个问题： <br/>
        假设你的初始状态设置了样式“width”,“height”,“background”,当你在终始状态都改变了这三个属性，那么all代表的就是“width”、“height”和“background”。如果你的终始状态只改变了“width”和“height”时，那么all代表的就是“width”和“height”。
    </p>
</div>
<div class="list">
    <h4>38.动画-过渡所需时间：transition-duration</h4>
    <p>
        <b class="red">transition-duration</b>属性主要用来设置一个属性过渡到另一个属性所需的时间，也就是从旧属性过渡到新属性花费的时间长度，俗称 <b class="red">持续时间</b>。
        案例演示：参照transition-property
    </p>
</div>
<div class="list">
    <h4>39.动画-过渡函数:transition-timing-function</h4>
    <p>
        <b class="red">transition-timing-function</b>属性指的是过渡的“缓动函数”。主要用来指定浏览器的过渡速度，以及过渡期间的操作进展情况，其中要包括以下几种函数： <br/>
        <img src="img/transition-timing-function.jpg" alt=""/> <br/>
        演示案例：参照transition-property
    </p>
</div>
<div class="list">
    <h4>40.动画-过渡延迟时间 transition-delay</h4>
    <p>
        <b class="red">transtition-delay</b>属性和transition-duration属性极其类似，不同的是transition-duration是用来设置过渡动画的持续时间，而transition-delay主要用来指定一个动画开始执行的时间，也就是说当改变元素属性值后多长时间开始执行。
        <br/>
        演示案例：参照transition-property
        有时我们想改变两个或者多个css属性的 <b>transition效果</b>时，只要把几个transition的声明串在一起，<b>用逗号（“，”）隔开</b>，然后各自可以有各自不同的 <b>延续时间</b>和其 <b>时间的速率变换方式</b>。但需要值得注意的一点：第一个时间的值为 transition-duration，第二个为transition-delay。<br/>
        例如：<b class="red">a{ transition: background 0.8s ease-in 0.3,color 0.6s ease-out 0.3;}</b>
    </p>
    <div class="lan">
        演示案例：<br/>
        通过transition属性将一个200px *200px的橙色容器，在鼠标悬浮状态时，过渡到一个300px * 300px的红色容器。而且整个过渡0.1s后触发，并且整个过渡持续0.28s。<br/>
        HTML: <br/>
        <textarea name="" id="" cols="30" rows="10" readonly>

        </textarea>
        CSS: <br/>
        <pre>
            .transition {
              width: 400px;
              height: 400px;
              margin: 20px auto;
              border: 2px dotted red;
            }
            .transition div {
              width: 200px;
              height: 200px;
              background-color: orange;
              -webkit-transition: all .28s ease-in .1s;
              transition: all .28s ease-in .1s;
            }
            .transition div:hover {
              width: 300px;
              height: 300px;
              background-color: red;
            }
        </pre>
        效果展示：
        <div class="transition">
            <div>鼠标放到我的身上来</div>
        </div>
    </div>
</div>
<div class="list">
    <h4>41.Keyframes介绍</h4>
    <p>
        <b class="red">keyframes</b>被称为 <b>关键帧</b>其类似于Flash中的关键帧。在CSS3中其主要以“@keyframes”开头，后面紧跟着是动画名称加上一对花括号“{…}”，括号中就是一些不同时间段样式规则。<br/>
    </p>
    <div class="lan">
        <pre>
            @keyframes changecolor{
              0%{
               background: red;
              }
              100%{
                background: green;
              }
            }
        </pre>
        在一个“@keyframes”中的样式规则可以由多个百分比构成的，如在“0%”到“100%”之间创建更多个百分比，分别给每个百分比中给需要有动画效果的元素加上不同的样式，从而达到一种在不断变化的效果。<br/>
        <b>经验与技巧：</b>在@keyframes中定义动画名称时，其中0%和100%还可以使用关键词 <b>from和to</b>来代表，其中0%对应的是from，100%对应的是to。<br/>
        兼容性：<br/>
        <img src="img/keyframes.jpg" alt=""/> <br/>
        Chrome 和 Safari 需要前缀 -webkit-；Foxfire 需要前缀 -moz-。<br/>
        案例演示：<br/>
        通过“@keyframes”声明一个名叫“wobble”的动画，从“0%”开始到“100%”结束，同时还经历了一个“40%”和“60%”两个过程。“wobble”动画在“0%”时元素定位到left为100px，背景色为green，然后在“40%”时元素过渡到left为150px,背景色为orange,接着在“60%”时元素过渡到left为75px，背景色为blue，最后“100%”时结束动画，元素又回到起点left为100px处，背景色变为red。<br/>
        HTML: <br/>
        <textarea name="" id="" cols="30" rows="10" readonly>
             <div class="keyframes">
                 鼠标放在我身上
             </div>
        </textarea>
        CSS: <br/>
        <pre>
            @keyframes wobble {
              0% {
                width: 100px;
                background:green;
              }
              40% {
                widtht:190px;
                background:orange;
              }
              60% {
                width: 220px;
                background: blue;
              }
              100% {
                width: 100px;
                background: red;
              }
            }
            div {
              width: 100px;
              height: 100px;
              background:red;
              color: #fff;
            }
            div:hover{
              animation: wobble 5s ease .1s;
            }
        </pre>
    </div>
    效果展示:
    <div class="keyframes">
        鼠标放在我身上
    </div>
</div>
<div class="list">
    <h4>42.调用动画</h4>
    <p>
        <b class="red">animation-name属性</b>主要是用来调用 @keyframes 定义好的动画。需要特别注意: animation-name 调用的动画名需要和“@keyframes”定义的动画名称 <b>完全一致（区分大小写）</b>，如果不一致将不具有任何动画效果。
        <br/>
        语法：<br/>
        <pre>
            animation-name: none | IDENT[,none|DENT]*;
        </pre>
        1、IDENT是由 @keyframes 创建的动画名，上面已经讲过了（animation-name 调用的动画名需要和“@keyframes”定义的动画名称完全一致）；<br/>
        2、none为默认值，当值为 none 时，将没有任何动画效果,这可以用于覆盖任何动画。 <br/>
        注意：需要在 Chrome 和 Safari 上面的基础上加上-webkit-前缀，Firefox加上-moz-。
    </p>
</div>
<div class="list">
    <h4>43.设置动画播放时间</h4>
    <p>
        animation-duration主要用来设置CSS3动画播放时间，其使用方法和transition-duration类似，是用来指定元素播放动画所持续的时间长，也就是完成从 <b>0%到100%</b>一次动画所需时间。单位：S秒
        <br/>
        语法规则： <br/>
        <pre>animation-duration: time[,time]* </pre>
    到目前为止支技animation动画的只有webkit内核的浏览器，所以我需要在上面的基础上加上-webkit前缀，据说Firefox5可以支持css3的 animation动画属性。
    </p>
</div>
<div class="list">
    <h4>44.设置动画播放方式</h4>
    <p>
        animation-timing-function属性主要用来 <b>设置动画播放方式</b>。主要让元素根据时间的推进来改变属性值的变换速率，简单点说就是动画的播放方式。 <br/>
        语法规则: <br/>
        <img src="img/animation-time-function.png" alt=""/> <br/>
        它和transition中的transition-timing-function一样，具有以下几种变换方式：ease,ease-in,ease-in-out,ease-out,linear和cubic-bezier。对应功如下：
        <br/>
        <img src="img/animation-time-function2.png" alt=""/> <br/>

    </p>
</div>
<div class="list">
    <h4>45.设置动画开始播放的时间</h4>
    <p>
        animation-delay属性用来定义动画开始播放的时间，用来触发动画播放的时间点。和transition-delay属性一样，用于定义在浏览器开始执行动画之前等待的时间。<br/>
        语法规则：<br/>
        <img src="img/animation-delay.png" alt=""/> <br/>
    </p>
</div>
<div class="list">
    <h4>46.设置动画播放次数</h4>
    <p>
        <b class="red">animation-iteration-count</b>主要用来定义动画的 <b class="red">播放次数</b>. <br/>
        <img src="img/animation-count.png" alt=""/> <br/>
        1、其值通常为整数，但也可以使用带有小数的数字，其默认值为1，这意味着动画将从开始到结束只播放一次。 <br/>
        2、如果取值为 <b class="red">infinite</b>，动画将会无限次的播放。<br/>
        <div class="notice">注意：Chrome或Safari浏览器，需要加入-webkit-前缀！</div>
    </p>
</div>
<div class="list">
    <h4>47.设置动画播放方向</h4>
    <p>
        animation-direction属性主要用来设置动画播放方向，其语法规则如下：<br/>
        <img src="img/animation-direction.png" alt=""/> <br/>
        1、normal是默认值，如果设置为normal时，动画的每次循环都是向前播放；<br/>
        2、另一个值是alternate，他的作用是，动画播放在第偶数次向前播放，第奇数次向反方向播放。 <br/>
    </p>
</div>
<div class="list">
    <h4>48.设置动画播放状态</h4>
    <p>
        animation-play-state属性主要用来控制元素动画的播放状态。 <br/>
        参数： <br/>
        其主要有两个值：<b class="red">running和paused。</b>
        其中running是其默认值，主要作用就是类似于音乐播放器一样，可以通过paused将正在播放的动画停下来，也可以通过running将暂停的动画重新播放，这里的重新播放不一定是从元素动画的开始播放，而是从暂停的那个位置开始播放。另外如果暂停了动画的播放，元素的样式将回到最原始设置状态。<br/>
        例如:页面加载时动画不播放。 <br/>
        <pre>animation-play-state:paused</pre>

    </p>
</div>
<div class="list">
    <h4>49.设置动画时间外属性</h4>
    <p>
        animation-fill-mode属性定义在动画开始之前和结束之后发生的操作。主要具有四个属性值：<b class="red">none、forwards、backwords和both</b>。其四个属性值对应效果如下：<br/>
        <img src="img/animation-fill-mode.png" alt=""/> <br/>
        在默认情况之下，动画不会影响它的关键帧之外的属性，使用animation-fill-mode属性可以修改动画的默认行为。简单的说就是告诉动画在第一关键帧上等待动画开始，或者在动画结束时停在最后一个关键帧上而不回到动画的第一帧上。或者同时具有这两个效果。
    </p>
</div>
<div class="list">
    <h4>50.关于动画的那些坑</h4>
    <p>
        关于CSS3的animation使用的一些坑，需要注意下！<br/>

        1. 对于一个要显示动画的元素，一定要先show，然后在执行动画语句。在iPhone设备上如果先执行动画语句再显示元素，则动画可能无效，android则没问题。<br/>

        2. 有时候我们执行动画语句的时候发现第一次并不生效，但是执行过一次，再次执行就好了。此问题只会在移动上出现，PC端则ok。解决办法就是设置animation-delay，一般0.2s就ok了。至于深层次的原因不得而知，猜测可能是因为移动毕竟渲染性能不如PC端，估计有时候元素还没有完全就绪吧。<br/>

        3. 使用-webkit-transition的时候，有些个别的浏览器版本可能会出现闪烁的情况，很坑爹。网上搜到的解决方案：<br/>
        -webkit-backface-visibility: hidden;（设置进行转换的元素的背面在面对用户时是否可见：隐藏）<br/>
        -webkit-transform-style: preserve-3d; （设置内嵌的元素在 3D 空间如何呈现：保留 3D ）。<br/>

        4. Internet Explorer 10、Firefox 以及 Opera 支持 @keyframes 规则和 animation 属性。<br/>
        Chrome 和 Safari 需要前缀 -webkit-。<br/>
    </p>
</div>
<div class="list">
    <h4>51.多列布局-columns</h4>
    <p>
        为了能在Web页面中方便实现类似报纸、杂志那种多列排版的布局，W3C特意给CSS3增加了一个 <b>多列布局模块（CSS Multi Column Layout Module）</b>。它主要应用在文本的多列布局方面，这种布局在报纸和杂志上都使用了几十年了，但要在Web页面上实现这样的效果还是有相当大的难度，庆幸的是，CSS3的多列布局可以轻松实现。
        <br/>
        <img src="img/columns.png" alt=""/> <br/>
        多列布局columns属性参数主要就两个属性参数：<b class="red">列宽和列数</b>。 <br/>
        <img src="img/columns2.png" alt=""/> <br/>
        <pre>columns:200px 2;</pre>
        浏览器兼容性支持: <br/>
        <img src="img/columns3.png" alt=""/>
    </p>
    <div class="lan">
        效果展示: <br/>
        <div class="columns">
            <h2>我要分列显示</h2>
            <p>为了能在Web页面中方便实现类似报纸、杂志那种多列排版的布局，W3C特意给CSS3增加了一个多列布局模块（CSS Multi Column Layout Module）。它主要应用在文本的多列布局方面。对于文本的多列布局，我想大家并不陌生，因为报纸和杂志上我们随处可见，这种布局在报纸和杂志上都使用了几十年了，但需要在Web页面上实现文本的多列布局，正如下图所示。</p>
            <p>为了能在Web页面中方便实现类似报纸、杂志那种多列排版的布局，W3C特意给CSS3增加了一个多列布局模块（CSS Multi Column Layout Module）。它主要应用在文本的多列布局方面。对于文本的多列布局，我想大家并不陌生，因为报纸和杂志上我们随处可见，这种布局在报纸和杂志上都使用了几十年了，但需要在Web页面上实现文本的多列布局，正如下图所示。</p>
        </div>
    </div>
</div>
<div class="list">
    <h4>52.多列布局:column-width</h4>
    <p>column-width的使用和CSS中的width属性一样，不过不同的是，column-width属性在定义元素列宽的时候，既可以单独使用，也可以和多列属性中其他属性配合使用。其基本语法如下所示 ；</p>
    <img src="img/column-width.png" alt=""/>
</div>
<div class="list">
    <h4>53.多列布局：column-count</h4>
    <p>
        column-count属性主要用来给元素指定想要的列数和允许的最大列数。其语法规则：<br/>
        <img src="img/column-count.png" alt=""/>
    </p>
</div>
<div class="list">
    <h4>53.多列布局:column-gap</h4>
    <p>
        column-gap主要用来设置列与列之间的间距，其语法规则如下： <br/>
        <img src="img/column-gap.png" alt=""/>
    </p>
</div>
<div class="list">
    <h4>54.列表边框：column-rule</h4>
    <p>column-rule主要是用来定义列与列之间的 <b>边框宽度、边框样式和边框颜色</b>。简单点说，就有点类似于常用的border属性。但column-rule是不占用任何空间位置的，在列与列之间改变其宽度不会改变任何列的位置。</p>
    <img src="img/column-rule.png" alt=""/>
</div>
<div class="list">
    <h4>55.跨列设置：column-span</h4>
    <p>
        <b class="red">column-span</b>主要用来定义一个分列元素中的子元素能跨列多少。column-width、column-count等属性能让一元素分成多列，不管里面元素如何排放顺序，他们都是从左向右的放置内容，但有时我们需要基中一段内容或一个标题不进行分列，也就是横跨所有列，此时column-span就可以轻松实现，此属性的语法如下。
        <br/>
        <img src="img/column-span.png" alt=""/>
    </p>
</div>
<div class="list">
    <h4>56.盒模型</h4>
    CSS中有一种基础设计模式叫盒模型，盒模型定义了Web页面中的元素中如何来解析。CSS中每一个元素都是一个盒模型，包括html和body标签元素。在盒模型中主要包括width、height、border、background、padding和margin这些属性，而且他们之间的层次关系可以相互影响，来看一张盒模型的3D展示图：
    <br/>
    <img src="img/box.jpg" alt=""/> <br/>
    从图中可以看出padding属性和content属性层叠background-image属性，层叠background-color属性，这个是存在的，它们四者之间构成了Ｚ轴（垂直屏幕的坐标）多重层叠关系。但是border属性与margin属性、padding属性三者之间应该是平面上的并级关系，并不能构成Ｚ轴的层叠关系。<br/>
    <b class="red">box-sizing</b> <br/>
    在CSS中盒模型被分为两种，第一种是w3c的标准模型，另一种是IE的传统模型，它们相同之处都是对元素计算尺寸的模型，具体说不是对元素的width、height、padding和border以及元素实际尺寸的计算关系，它们不同之处是两者的计算方法不一致，原则上来说盒模型是分得很细的，这里所看到的主要是外盒模型和内盒模型，如下面计算公式所示：<br/>
    <img src="img/box2.png" alt=""/><br/>
    <img src="img/box3.png" alt=""/> <br/>
    在CSS3中新增加了box-sizing属性，能够事先定义盒模型的尺寸解析方式，其语法规则如下：<br/>
    <pre>box-sizing: content-box | border-box | inherit</pre>
    <img src="img/box4.png" alt=""/> <br/>
    其中最为关键的是box-sizing中content-box和border-box两者的区别，他们之间的区别可以通过下图来展示，其对盒模型的不同解析： <br/>
    <img src="img/box5.jpg" alt=""/> <br/>
    效果展示：<br/>
    没有增加box-sizing:box-border
    <div class="box1">
        <div class="header"><h1>Header Content</h1></div>
        <div class="page">
            <div class="main"><h1>Main Content</h1></div>
            <div class="sidebar"><h1>Sidebar Content</h1></div>
        </div>
        <div class="footer"><h1>Footer Content</h1></div>
    </div>
    增加box-sizing:box-border
    <div class="box2">
        <div class="header"><h1>Header Content</h1></div>
        <div class="page">
            <div class="main"><h1>Main Content</h1></div>
            <div class="sidebar"><h1>Sidebar Content</h1></div>
        </div>
        <div class="footer"><h1>Footer Content</h1></div>
    </div>
</div>
<div class="list">
    <h4>57.弹性布局：flex</h4>
</div>
</body>
</html>